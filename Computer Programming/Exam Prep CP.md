---
Tags: 
Created: 2022-10-23 16:43:10
---
(Links:: [[Computer Programming]])
# Basic knowledge
- Programming is all about precision. Programs must be created precisely to run correctly. Ex: = and == have different meanings.
- Using i where j was meant can yield a hard-to-find bug.
- Declaring a variable as int when char was needed can cause confusing errors.
- Not considering that n could be 0 in sum/n can cause a program to fail entirely in rare but not insignificant cases.
- The difference between typing x/2 vs. x/2.0 can have huge impacts.
- Counting from i being 0 to i < 10 vs. i <= 10 can mean the difference between correct output and a program outputting garbage.

- safe vs unsafe conversion types:
  safe conversion = no information or precision is lost; e.g. from int to double
  unsafe = information or precision can be lost; e.g. int to char or double to int
- symbolic constants improve readability and maintainability
- Syntax error = violating a programming language's rules on how symbols can be combined to create a program = a compile-time error
- A logic error = a bug that prevents the program from running as intended; the program does not do the desired things
- Circuits called **processors** are there to process aka execute a list of desired calculations with each calculation called an **instruction** and these instructions operate on **data** and are stored in a **memory**
	- A computer is basically a processor interacting, and communicating with a memory 
- Variables:
	- A variable declaration is a statement that declares a new variable, specifying the variable's name and type
	- **common error**: a programmer must ensure that a program assigns a variable with a value before reading → don't write assignment statements in reverse
	- **good practice**: initialise the variable immediately after declaring it
- Integer division does not generate any fraction 
	- both operands on the sides of the division operator must be integers to perform a successful integer division
	- if one of the operands is a floating point number, then the integer is conversed to a floating point number and floating point division occurs
	- integer division cannot handle division with either on of the operands as 0 → a divide-by-zero error occurs at runtime if a divisor is 0 → run-time error ⇒ causes a program to terminate early and never reaches the desired output
	- the **modulo operator** % evaluates the remainder of the division of two **integer** operands: e.g. 
	  3%4 = 3 
	  5%3 = 2
- **type conversions** = conversions from one data type to another: see unsafe vs safe type conversions
	- implicit conversions are automated conversions 
	  e.g. if an expression has a double and an integer, the integer is automatically conversed to a double
	- explicit conversion can be done by a **type cast**:
	  `avgKidsPerFamily = static_cast<double>(kidsInFamily1 + kidsInFamily2) / static_cast<double>(numFamilies);`
	  → **common error**: casting the entire result of integer division rather than the operands, which can lead to not getting the desired floating-point division
	  → don't cast final results; cast the operands
- **String** = a sequence of characters and a string literal surrounds a character sequence with double quotes
	- sometimes you also want to get the whitespace characters within a string, then you can use the function:
	  ```cpp
	  getline(cin, firstString);
	  getline(cin, secondString);
	  ```
	  → if you have the following statements:
	  Hello there!
	  Welcome.
	  firstString will get "Hello there!"
	- An **overflow** occurs when the value being assigned to a variable is greater than the maximum value the variable type can store
	  → this will yield a **compiler warning**
	  → There can be overflow only if the signs of two numbers are same, and sign of sum is opposite to the signs of numbers.
	- A data type overflow works like a clock: your clock goes 9, 10, 11, 12, and then from 12, since that is the max value on a clock, it goes back to the minimum value, which is 1
	- An **integer overflow** will cause an output to be the minimum value 
- the **rand()** function returns a random integer each time the function is called in the range of 0 to RAND_MAX
	- generating random integers in a specific range not starting from 0 
	  e.g the range is 10 to 15:
	  number of possible values: 15 - 10 + 1
	  `(rand()% 15 -10 + 1) + 10`
	- The integers generated by rand() are known as pseudo-random. "Pseudo" means "not actually, but having the appearance of". The integers are pseudo-random because each time a program runs, calls to rand() yield the same sequence of values.
	- For the first call to rand(), no previous random integer exists, so the function uses a built-in integer known as the **seed**.
		- you can change the seed using the function **srand()**
		- only if the seeding value is different each time the program runs, you'll get a unique sequence of numbers, but if the seeding value is **constant**, the output will always be the same
		- in the example beneath the seed value is different every time, because we use **time** that the user needs, which is changing continuously, as our seeding value, giving us a different output every time.
		  ```cpp
		#include <iostream>
		#include <cstdlib>
		#include <ctime> // Enables use of time() function
		using namespace std;
		int main() {
		srand(time(0)); // Unique seed
		cout << rand() << endl;
		cout << rand() << endl;
		cout << rand() << endl;
		return 0;```
# if-else branches
- a **branch** is a program path taken only if an expression's value is **true**
	- an if-else structure has two branches
	- an if-else if-else has three branches
	- an if-else statement executes one group of statements when an expression is true and another group of statements when the expression is false
	- use the equality operator in an if-else expression, otherwise:
	  ```cpp
	  numItems = 3;
	  if (numItems = 10) {
	  numItems = numItems + 1;
	  } //the value of numItems is asisgned with 10, so the value will be 1
	  ```
		- Logical operator
		  a && b
		  **Logical AND**
		  (&&): true when both of its operands are true
		  a || b
		  **Logical OR**
		  (||): true when at least one of its two operands are true
		  !a
		  **Logical NOT**
		  (!): true when its one operand is false, and vice-versa.
	- **common error**: using bitwise operator instead of logical operator: & instead of &&
		- not using the curly braces to indicate the branch's statement, which can lead to mistakenly thinking a statement is part of a branch
	- an if-else statement can be written as a **conditional expression**:
		- (condition) ? exprWhenTrue : exprWhenFalse
		  For example, if x is 2, then the conditional expression (x == 2) ? 5 : 9 * x evaluates to 5.
# switch cases
- a switch-statement can more clearly represent multi-branch behaviour involving a variable being compared to a **constant** value
	- the program executes the first case whose constant expression matches the value of the switch expression
	- no matches at all, then **default** case is reached ⇒ always have a default case
	- include a break statement at the end of a case's statements, unless a break has been reached, the statement will hold the value of the latest statement
	  → Omitting the break statement for a case will cause the statements within the next case to be executed.
- a switch statement can also be written as multi-branch if-else statement
```
switch (expression) {
case constantExpr1:
// Statements
break;
case constantExpr2:
// Statements
break;
...
default: // If no other case matches
// Statements
break;
}
```

# loops
- a loop is a program construct that **repeatedly** executes the loop's statements (known as the loop's body) while the loop's expression is true
	- each time through a loop's statement is called an **iteration**
- for loops
	- a loop variable initialization
	- a loop expression
	- a loop variable **update**; incrementing or decrementing
- while loops
```cpp
#include <iostream>
using namespace std;
int main() {
	int userNum;
	cin >> userNum;
	while (userNum > 0) {
		cout << userNum % 10 << endl;
		userNum = userNum / 10;
	}
	return 0;
}
```
- which loop to use?
	- for loops: number of iterations is computable before the loop like iterating N times
	- while loops: number of iterations is not easily computable before the loop like iterating until the input is 'q'

- nested loops
```cpp
#include <iostream> // output something
const int ROWS = 5
const int COLUMNS = 4
int main() {
	for ( int r=0; r<ROWS; r++){
		for ( int c=0; c<COLUMNS; c++){
			std::cout << “(“ << r << “,” << c << “)” ;
		}
		std::cout << std::endl;
	}
	return 0;
}
```

- Some variables only need store a small set of named values. For example, a variable representing a traffic light need only store values named GREEN, YELLOW, or RED. An **enumeration type (enum)** declares a name for a new type and possible values for that type.
`enum LightState {LS_RED, LS_GREEN, LS_YELLOW, LS_DONE}; LightState lightVal;`

# input streams
```cpp
ifstream inFS;
inFS.open("booksFile.txt");
int numBooks;
int numStudents = 40;
inFS >> numBooks;
cout << "Books per student: ";
cout << numBooks / numStudents;
```
- A **common error** is to type **cin >> num1**; when actually intending to get data from a file as in **inFS >> num1**.
- Another common error is a mismatch between the variable data type and the file data; If the data type is int but the file data is "Hello".
- A stream error occurs when insertion or extraction fails, causing the stream to enter an error state.
	- Ex: If a file has the string two but the program attempts to extract an integer, the extraction will fail and the stream will enter an error state.
- A stream's error state is cleared using **clear()**. Ex: cin.clear() clears the error state from cin. 
	- The function ignore(maxToIgnore, stopChar) ignores characters in the stream buffer.
	- Ex: cin.ignore(10, '\n') ignores up to 10 characters in the stream buffer, or until a '\n' character is encountered.

# functions
- A user defined function is defined by its sets (types) of input parameters, its name, the set or type of the return value and the algorithm that computes the return value from the input values
	- parameters given in the declaration of a function are called **formal parameters 
	  int f (int x);**
	- parameters given in the call of a function are called actual **parameters
	  y = f(a);**
	- parameter passing is about how actual parameters relate to the formal parameters
	  → pass-by-value copies the actual parameters into the formal parameters
	  → pass-by-reference allows us to modify variables by passing them into a function
	  ⇒ A reference refers to the value of another variable, so it does not store the value twice
	  ⇒ The programmer must initialise each reference with an existing variable, which can be done by initialising the reference variable when the reference is declared, otherwise it will give a compiler error
- **common errors**: forgetting the return statement or returning the wrong variable
```cpp
#include <iostream>
using namespace std;
void ConvHrMin(int timeVal, int& hrVal, int& minVal) {
	hrVal = timeVal / 60;
	minVal = timeVal % 60;
}
int main() {
	int totTime;
	int usrHr;
	int usrMin;
	totTime = 0;
	usrHr = 0;
	usrMin = 0;
	cout << "Enter total minutes: ";
	cin >> totTime;
	ConvHrMin(totTime, usrHr, usrMin);
	cout << "Equals: ";
	cout << usrHr << " hrs ";
	cout << usrMin << " min" << endl;
	return 0;
}
```
- function templates: A **function template** is a function definition having a special type parameter that may be used in place of types in the function.
```cpp
template<typename TheType>
TheType TripleMin(TheType item1, TheType item2, TheType item3) {
	TheType minVal = item1; // Holds min item value, init to first item
	if (item2 < minVal) {
		minVal = item2;
	}
	if (item3 < minVal) {
		minVal = item3;
	}
	
	return minVal;
}
```

# error-handling
## Exceptions
```
// ... means normal code
...
try { ... ... // If error detected throw objectOfExceptionType; ... ...
}
catch (exceptionType& excptObj) { // Handle exception, e.g., print message
}
...
//Resume normal code below catch
```

## Assert()
- About handling problems at run time
- Your program makes certain assumptions under which it is going to work, e.g.:
  The user does not enter incorrect data
  The parameter n for a function fib(n) is larger than 0
  The vector given to binarySearch(v) is sorted
- **assert()** is for **debugging** -> something unexpected happens and you want to know where it went wrong
```cpp
#include <cassert>
void assert (int expression) {
	if (expression == 0) {
	// print error message
	// abort the program
	}
}
```
## Assert vs exceptions vs error handling
- assertions: for debugging
	- if an assert() fails, **it is your fault**
- exceptions: for exceptional circumstances at run time
	- your code is basically OK
	  e.g. open a file that is not there
	  std::vector.at() called with invalid index
- error handling: for conditions you must handle; manually testing 
	- you expect a number from cin but the user types something else

# recursion

- a function that calls itself is a recursive function
	- direct recursion
	- indirect recursion
- prevent **infinite recursion** by making a **base case**
	- **common error**: infinite recursion because the function doesn't reach a base case
	- compare this with not updating a control variable in a loop, leading to an infinite loop
- recursion uses more memory and are generally slower than loops, but they are more elegant and it gives another level of abstraction
```cpp
#include <iostream>
using namespace std;
void CountDown(int countInt) {
	if (countInt == 0) {
		cout << "GO!\n";
	}
	else {
		cout << countInt << endl;
		CountDown(countInt - 1);
	}
}
int main() {
	CountDown(2);
	return 0;
}
```
- when a function is called, a new **stack frame** is pushed onto the **runtime stack**, where the parameters and other local variables are stored
	- each time a recursive function calls itself, a new stack frame is created
	- each recursive invocation has its own set of local variables that do not interfere with the local variables of the other invocations
	- each new call creates new local variables in memory
	  → a **stack overflow** occurs when the stack frame for a function call extends past the end of the stack's memory
# classes
- the class construct defines a new type that can group data and functions to form an object
	- variables that are made of class types are called **objects** and a new object variable is an **instance**
	- functions inside classes are called **methods** or **member functions**
	  → a member function can access its class member variables, so both the public and the private part
	- by default everything is **private** in a c++ class
	- if we don't write our own, then the compiler automatically creates a **default** and **copy constructor** and an **assignment operator** for every class
		- if you write any constructor, you must write the default constructor on your own
		- A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter)

- **inline member functions**: functions that are defined within the class and not outside the class using the scope resolution operator ::
```cpp
class MyClass {
	public:
		void Fct1();
	private:
		int numA;
};
void MyClass::Fct1() {
	numA = 0;
}
```

# pointers
- a **pointer** is a variable that contains a **memory address**
	- **vectors** use **dynamically allocated arrays**
	  → the vector class uses pointers to store the memory location of the internal array, that gets dynamically allocated ⇒ changing the locations in memory
	  → the ability to dynamically change the size of a vector makes vectors more powerful than arrays
	  → when you try to access an invalid index in an array, the compiler will not complain and will give you a random value, while when done this with a vector, the compiler will give you **a segmentation fault**
- pointers can be used to call class member functions
	- the **this** pointer enables access to an object's data members within the object's class member functions
	- a data member can be accessed using this and the member access operator for a pointer
	  `e.g. this → sideLength;`
	- a pointer has a data type and the data type determines what types of address is stored in the pointer
		- typically, a pointer is initialised with another variable's address
			- the **reference operator** (&) obtains a variable's address
			  e.g. &someVar returns the memory address of variable someVar
			- when a pointer is declared, the pointer variable holds an unknown address until the pointer is initialised
	- **dereferencing** a pointer: to retrieve the data to which the pointer variable points
		- **common error**: dereferencing a null pointer will cause the program to crash
	- common pointer errors:
		- using dereference operator when initialising a pointer
		  e.g. *someVar = &someOtherVar;
		- declaring multiple pointers on the same line and forgetting the * before each pointer name
	- **common runtime errors**:
		- dereferencing a pointer that hasn't been initialised
			- dereferencing a null pointer
			  ⇒ a pointer should always contain a valid address before the pointer is dereferenced
	- the **new** operator allocates memory for the given type and returns a pointer to the allocated memory
		- if the type is a class the new operator calls the class' constructor after allocating memory for the class' member variables
		  ```cpp
		  Point* point2 = new Point(8, 9);
		  (*point2).Print(); ⇒ point2→Print();
		  ```
	- when using a pointer to an object, the member access operator (→) allows access to the object's members with the syntax **a→b** instead of **(*a)b**
	- the **delete** operator deallocates or frees a block of memory that was allocated with the new operator
		- **common error**: dereferencing a pointer whose memory has been deallocated
		- the delete operator can only be used on the pointer that points to memory allocated with the new operator
		- a **memory leak** occurs when a program that allocates memory loses the ability to access the allocated memory, typically due to failure to properly destroy/free dynamically allocated memory
			- **common error**: failing to free allocated memory that is no longer used resulting in a memory leak
		- a program's memory usage has four different regions:
			- **code**: instructions
			- **static memory**: global variables
			- the **stack**: function's local variables; invocation adds the local variable to the stack and return removes it; automatic memory
			- the **heap**: region where the **new** operator allocates memory and where the **delete** operator deallocates memory; free store
		- **garbage collection**: automatic process of finding and freeing unreliable allocated memory locations
		- **destructors** are needed when destroying an object involves more work than simply freeing the object's memory
			- when an object's data member referred to as a sub-object has allocated additional memory 
			- called automatically when a variable of that class type is destroyed 
			- no parameters and no return values
			  `~LinkedList();`
		- **copy constructor** is a constructor that automatically is called when an object of the class type is **passed by value** to a function and when an object is initialised by copying another object during declaration
			- **deep copy**; allocating and copying data members for pointers
			- **shallow copy**; only the data members' values
			  ```cpp
			  class MyClass {
			  public:
			  ...
			  MyClass(const MyClass& origClass);
			  ...
			  };
			
				MyClass::MyClass(const MyClass& origClass) {
				cout << "Copy constructor called." << endl;
				dataObject = new int; // Allocate sub-object
				*dataObject = *(origClass.dataObject);
				}
				```
		- copy assignment operator = default assignment operator behaviour
		  ```cpp
			  MyClass& MyClass::operator=(const MyClass& objToCopy) {
				  cout << "Assignment op called." << endl;
				  if (this != &objToCopy) { // 1. Don't self-assign
				  delete dataObject; // 2. Delete old dataObject
				  dataObject = new int; // 3. Allocate new dataObject
				  *dataObject = *(objToCopy.dataObject); // 4. Copy dataObject
			  }
			  return *this;
		  }
		  ```

___
References: